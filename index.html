<!DOCTYPE html>
<html>
<title>W3.CSS Template</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js" type="text/javascript"></script>
<script src="jquery.toc.js" type="text/javascript"></script>

<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif}
.w3-sidenav a,.w3-sidenav h4 {padding: 12px;}
.w3-bar a {
    padding-top: 12px;
    padding-bottom: 12px;
}

:target:before {
content:"";
display:block;
height:40px; /* fixed header height*/
margin:-40px 0 0; /* negative fixed header height */
}

.break {page-break-before: always;}

</style>
<body>

<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-theme w3-top w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-opennav w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()"><i class="fa fa-bars"></i></a>
    <a href="index.html" class="w3-bar-item w3-button w3-theme-l1">User Manual</a>
    <a href="modes.html" class="w3-bar-item w3-button w3-theme-l1">Mode Reference</a>
  </div>
</div>

<!-- Sidenav -->
<nav class="w3-sidenav w3-collapse w3-theme-l5 w3-animate-left" style="z-index:3;width:250px;margin-top:51px;" id="mySidenav">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="close menu">
    <i class="fa fa-remove"></i>
  </a>
  <h4><b>Contents</b></h4>
<ul data-toc="div.w3-main" data-toc-headings="h1,h2"></ul>
</nav>

<!-- Overlay effect when opening sidenav on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidenav is visible -->
<div class="w3-main" style="margin-left:250px;">

  <div class="w3-row w3-padding-64">
    <div class="w3-container">


<p class="break"></p><br/>


<h1>Chapter Zero: Quick-start Guide</h1>

<h3>Let there be visuals!</h3>

<p>Welcome to <strong>The ETC Television Center</strong> (or simply <strong>ETC</strong> to her friends)! Time is money so let’s get you up and running…</p>

<hr />

<h2>Package Manifest</h2>

<p>Along with this card, there are two main items in the box you just opened.</p>

<ul>
	<li><strong>Your ETC.</strong> Also note that a tiny white USB drive is also plugged in on the right side of the unit. This drive holds the patches that ETC will use to paint its pictures.</li>
	<li><strong>Its power adapter.</strong> While the power supply has prongs for US-style wall sockets, it will work with input voltages from 100 to 240VAC at 50/60Hz. You may need an adapter for the shape of your wall socket.</li>
</ul>

<hr />

<h2>Getting Started</h2>

<p>Follow these steps to make your sound visual.</p>

<ol>
	<li>Connect the <code>HDMI Out</code> port to a powered-up HDMI® monitor.</li>
	<li>Connect the power adapter to a power outlet, and then connect its plug to the <code>9VDC</code> power port, the leftmost port on the back of ETC. The top row’s <em>Status LED</em> will indicate progress, glowing light blue as ETC is booting up, and then white when things are operational. Your connected monitor will also show the boot up process.</li>
	<li>Press the top row’s <em>On Screen Display</em> button (ICON IMAGE). Your monitor should now show an overlay of current system information. You can press the button once more to toggle off this display.</li>
	<li>To transmute audio to video, connect a 1/4&quot; audio cable to the <code>Audio In</code> port, and turn up the top row’s <em>Audio Input Gain</em> knob (ICON IMAGE). (Feel free to crank it; you won’t hurt ETC’s ears.) As long as an audio signal is coming in, you should start getting pictures on your HDMI display.</li>
	<li>When you have had enough fun for now, press the <em>Shutdown</em> button (ICON IMAGE) on the top left of ETC. After holding it down for a couple seconds, the <em>Status LED</em> will glow pink while the device shuts itself down. Once the <em>Status LED</em> is off, it is safe to unplug the power supply.</li>
</ol>

<h1>Chapter One: ETC™ Concepts</h1>

<h3>What is this box with the curious icons?!‽</h3>

<p>Again, welcome to the world of <strong>ETC</strong>! As this video instrument has an inherent range and can work for different people in different ways, let us start by talking about what it is and where on Earth (or beyond!) it came from. We’ll then look at some of the basic concepts in play and make sure we are speaking the same language. Then we’ll close with a word on using this guide, preparing you to go forth and visually multiply. So back to our origin story…</p>

<hr />

<h2>Where did The ETC Television Center come from?</h2>

<p>We at Critter &amp; Guitari (hello!) have released video boxes before, and we are still rather fond of those devices. Their intended use was simple:</p>

<ol>
	<li>Plug in an audio input, feeding live sound to the box.</li>
	<li>Plug in a live video output for a projector or other display.</li>
	<li>Set a couple knobs.</li>
	<li>Go back to playing music, and live visuals will accompany you.</li>
</ol>

<p>While ETC preserves this “self-service” approach, a number of other modes and options are present.</p>

<h4>Is ETC ready to go out of the box?</h4>

<p>Yes! Once ETC is connected and powered up (see chapter zero), it will automatically begin creating visuals with the factory modes.</p>

<h4>Does ETC have different methods of creating video?</h4>

<p>Yes! You can cycle forwards and backwards through ETC’s current visual <em>modes</em> by pressing the two <em>Mode Selector buttons</em> on the bottom left of the front panel (around the eyeball icon). Each valid patch on the USB stick is loaded as a mode, and the preloaded factory content provides a survey of unique visual effects.</p>

<h4>Can I play ETC as a video instrument?</h4>

<p>Yes! The knobs and buttons on ETC’s front panel provide direct access to the inner workings of ETC and each available visual mode. To expand your control options, you can connect a pedal to ETC’s <code>Foot Switch</code> port, or even wire up a MIDI controller to the <code>MIDI In</code> port, etc.</p>

<h4>Can I just plug in ETC and go back to playing bass?</h4>

<p>Yes! If audio is running into ETC, a couple of knob tweaks should get you a steady stream of responsive visuals.</p>

<h4>Can I capture still images generating by ETC?</h4>

<p>Yes! The bottom row of ETC has a dedicated <em>Screenshot button</em> (with a camera icon). Pressing this button will capture the current output of ETC to an image file on the USB drive. And if you are a hacker-type, you could even craft a mode that injects the most recently captured screenshot back into the current output. Think feedback, recursion, or something less imaginable.</p>

<h4>Can I feed still images into ETC as source material?</h4>

<p>Yes! Modes can be made to use still images from within the mode’s file structure. You might even find some examples of this in our mode repository (URL).</p>

<h4>Hold up. Can I edit ETC’s modes?</h4>

<p>Yes! All of ETC’s modes are written in <strong>Python</strong> using the graphics library of <strong>Pygame</strong>. This means that for the brave, every mode on your USB drive could be edited. And for the truly bold, new modes of your own can be created.</p>

<h4>So, there is no “right” way to use ETC?</h4>

<p>Exactly! ETC is a vehicle for creating visuals. You may want that in a live performance environment, or you might wish to capture and edit the output. Perhaps you want someone to operate ETC throughout your set, or maybe you yourself just lean over and switch <em>scene</em> presets ever song or two. You might want to get out a text editor and code a new mode, but you can just as easily download new modes that others have written. Any of these choices are valid as long as they serve your purposes!</p>

<hr />

<h2>ETC Concepts</h2>

<p>Our introduction and the sticker on the back of ETC have already hinted at certain ideas and the terms we are using to express them. Let’s take a moment to be clear about the concepts in play.</p>

<p>An ETC <strong>mode</strong> is a method for creating visuals. In audio terms, you could think of each <em>mode</em> as a <em>patch</em>. The mode can be switched instantaneously from the front panel. Each available mode lives on the attached USB drive along with any support files it may need.</p>

<p>In building the initial factory modes, we have considered modes as falling into two broad categories:</p>

<ul>
	<li>A <em>scope mode</em> directly visualizes the incoming audio signal. This could take the form of a classic “oscilloscope” signal representation or something far different. Either way, animation is continuously updated with the received audio.</li>
	<li>A <em>trigger mode</em> also visualizes the incoming audio signal, but it doesn’t draw continually as an oscilloscope mode would. Often, a threshold must be crossed for the audio to get visualized. This could be an audio threshold, where only certain levels of sound cause substantial visual activity. The threshold could also come via a button (such as the <em>Trigger button</em>), received MIDI notes, or something else altogether.</li>
</ul>

<p>To make things easy to read, a factory mode whose name start with <code>S - </code> is scope mode, and one beginning with <code>T - </code> is a trigger mode. But as the descriptions above suggest, there is plenty of wiggle room as modes can readily blend these ideas or go off in completely new directions. Thinking in the scope/trigger paradigm to start is a good way to both help you understand the factory modes and organize your own ideas for new modes or new even categories.</p>

<p>As for the controls of ETC, we think of them as falling into a couple of categories.</p>

<ul>
	<li><strong>Foreground controls</strong> change parameters of the local mode. Consisting of the four numbered knobs on the front panel, these controls affect settings defined within the currently loaded mode.</li>
	<li><strong>Background controls</strong> set global parameters. These include the <em>Background Color</em> knob and the <em>Auto Clear Toggle</em>. Even when you change modes, these parameters are persistent.</li>
</ul>

<p>An ETC <strong>scene</strong> is essentially a preset. Each scene stores which mode was being used along with the values of all five knobs (including the four foreground controls and the <em>Background Color</em> knob) and whether the <em>Auto Clear Toggle</em> button is enabled or disabled.</p>

<p>The next chapter will explore how to put all of these ideas into action, but understanding modes versus scenes (and foreground controls versus background controls) will let us hit the ground running.</p>

<hr />

<h2>How to Use This Manual</h2>

<p>Certain chapters (such as this one!) are relevant to everyone. But depending on how you plan to use ETC, some information may prove more valuable to you.</p>

<ul>
	<li>Regardless of your intentions, the quick-start (chapter zero) and concepts information (chapter one) will benefit you.</li>
	<li>For out-of-the-box usage, the information on operating the hardware (chapter two) will be a central guide, walking you through the functions of the various panel controls and ports. And the factory mode information (see URL?) will walk you through the standard modes and their parameters.</li>
	<li>If you are looking to load additional modes into ETC, then chapter three will also be useful to you. Then you can scour our online repository of additional ETC modes (URL?).</li>
	<li>If you want to edit modes or even create some of your own, chapter four will help you prepare your work for ETC.</li>
</ul>

<p>Just realize that how you use ETC today may be very different from how you use it a week from now. This is to say feel free to skip information that isn’t of use to you today; you may find that later chapters appreciate in value over time. </p>

<h1>Chapter Two: General Operation of ETC™</h1>

<h3>Knowing the knobs and buttons is worth more than a thousand words.</h3>

<p>Up to this point, we have talked about getting ETC plugged in and running, we have discussed some ways to use the device, and we have covered the concepts that underpin the system. So now we should get on with it and make some pretty pictures.</p>

<p>In this chapter, we will walk through ETC from the user’s perspective, with hands fixed on the hardware controllers and eyes on the back panel’s ports. This will naturally address the role and relation of each control within ETC’s structure. Taken as a whole, we will be painting our own picture of ETC’s functions and general operation.</p>

<p>So let’s grab the knobs, push the buttons, and watch the pictures, now, as they fly through the air…</p>

<hr />

<h2>Row 1: Systemic Controls</h2>

<p>The top row of ETC has a number of system-level controls and the only direct feedback element that faces the user. We will take these items from left to right.</p>

<p><strong>The <em>Shutdown</em> button</strong> is a trigger that does exactly what its name implies: it tells ETC to begin shutting the system down.</p>

<p>When ETC is connected to power, the system automatically begins booting up (as described in chapter zero). When you are done using ETC or need to power it down for a moment, hold down the <em>Shutdown</em> button for two seconds or so. During the shutdown process, the <em>Status LED</em> will go from white to pink, and once the unit is ready to be safely unplugged from power, the light will finally go out .</p>

<p><strong>The <em>Status LED</em></strong> is a light that illuminates in various colors to reflect either the state of the ETC hardware, or to indicate that a particular action is being taken or a type of message was just received.</p>

<p>When the <em>Status LED</em> is glowing in one of these colors, it is indicating the following hardware state:</p>

<ul>
	<li>Light blue: ETC is currently starting up. (It has probably just received power.)</li>
	<li>Red: ETC encountered an error while starting up. If you consistently receive this message, either consult our <a href="https://www.critterandguitari.com/pages/FAQ">FAQ page</a> or <a href="https://www.critterandguitari.com/pages/contact-us">contact us</a>!</li>
	<li>White: ETC is currently running normally.</li>
	<li>Pink: ETC is in the process of shutting down. (You likely just pressed the <em>Shutdown</em> button.)</li>
	<li>Dim: When the LED is not illuminated, then ETC is not running. Either you haven’t powered it on yet, or you have already shut down the device.</li>
</ul>

<p>And when the <em>Status LED</em> is showing one of these colors, it is relaying the following information:</p>

<ul>
	<li>Yellow: A screenshot is being written to the USB drive. (You likely just pressed the <em>Screenshot</em> button.)</li>
	<li>Green: When the LED flashes green, a MIDI message (such as a note or continuous controller message) was just received by ETC. When the light stays a solid green, a steady stream of MIDI messages (likely clock messages) is arriving at ETC.</li>
	<li>Purple: A message was just received via the <code>Foot Switch</code> port.</li>
</ul>

<p><strong>The <em>On Screen Display</em> button</strong> is a toggle that calls up an overlay of current system information.</p>

<p>(SCREENSHOT: On Screen Display)</p>

<p>Information is displayed in two columns. On the left side are:</p>

<ul>
	<li>The current mode.</li>
	<li>The most recently loaded scene (if applicable).</li>
	<li>An indicator for incoming MIDI notes.</li>
	<li>The current positions of the background and foreground knobs.</li>
	<li>An indicator of whether the threshold trigger is currently engaged.</li>
	<li>A level meter for incoming audio signal.</li>
	<li>An indicator of whether the background clearing function is currently enabled.</li>
</ul>

<p>The right column includes:</p>

<ul>
	<li>Thumbnails of the several most recent screen grabs.</li>
	<li>The incoming MIDI channel that ETC is listening to.</li>
	<li>ETC’s current IP address, in case the USB Wi-Fi dongle is in use. (For more information, see chapter four.)</li>
	<li>How much of ETC’s memory (RAM) is currently being used.</li>
	<li>The current frames per second (FPS) output of ETC.</li>
</ul>

<p>Pressing the <em>On Screen Display</em> button a second time will toggle the display back off screen.</p>

<p><strong>The <em>Audio Input Gain</em> knob</strong> does nothing to affect the internal video system or change the audio that you hear, but it is probably the most consequential control for ETC. This knob scales the incoming audio level before it is processed by ETC for use in the current visual mode. The purpose of this knob is to adjust the strength of the audio signal and scale it into an appropriate range for visualization.</p>

<p>The appropriate setting for this knob will depend on the type of signal you are connecting and the mode you are using. For example:</p>

<ul>
	<li>Are you connecting a guitar or microphone directly to ETC’s <code>Audio In</code> port? Then you will probably need a higher gain setting for this relatively weak signal.</li>
	<li>Are you connecting a powered instrument (such as a synthesizer) output, or even the full band’s output from a mixer? Then the <em>Audio Input Gain</em> knob can probably be a bit lower.</li>
	<li>Are you doing something we can’t imagine? Good job! Adjust the gain knob until you find an appropriate setting for the modes you are using.</li>
</ul>

<hr />

<h2>Row 2: Background Controls</h2>

<p>While the second row is the most sparsely populated, its two controls are really the glue that hold transitions together for ETC. These background controls set global parameters that are held steady not matter what mode you are in or if you recall a scene.</p>

<p><strong>The <em>Background Color</em> knob</strong> allows you to set the “canvas color” on top of which mode paints its scene. Turning this knob cycles through the available colors.</p>

<p><strong>The <em>Auto Clear Toggle</em> button</strong> is a nice toggle effect available in all situations. This is easier explained with a brief word on how ETC carries out its drawing functions.</p>

<p>Each ETC mode contains one <code>draw</code> function, which is triggered 30 times per second to generate 30 frames per second (FPS) of output. The default behavior for a drawing program like this is to clear the screen right before the <code>draw</code> function is run. (This clearing results in the color set by the <em>Background Color</em> knob covering the screen.) But breaking the rules can be interesting.</p>

<p>The <em>Auto Clear Toggle</em> button allows us to disable this clearing function. When clearing has been toggled off, each new frame of video draws on top of the previous frame, which can create a “hall of mirrors,” recursive effect. Hitting the <em>Auto Clear Toggle</em> button again restores the normal clear function.</p>

<p>So there is a dependent relationship between the <em>Auto Clear Toggle</em> button and the <em>Background Color</em> knob. When clearing has been toggled off, the <em>Background Color</em> knob has no effect since the background is never getting painted. When the button is toggled back to normal clearing behavior, the set background color will be applied again.</p>

<hr />

<h2>Row 3: Foreground Controls</h2>

<p>The third row consists of four numbered knobs. Formally, we could call them <em>Foreground 1 Control</em> knob,<em>Foreground 2 Control</em> knob, etc. Or we could be more collegial and simply call them foreground knob <code>3</code> and foreground knob <code>4</code>. Either would be appropriate.</p>

<p>Each of these foreground controls represents a top-level parameter within the mode. This could be a single parameter that controls one discrete element of the mode, or it could be several parameters wrapped into a true “macro” function. While we don’t know the specifics for each mode (see the factory modes reference (URL) for that type of per-mode information), we know that each patch should have four top-level controls, and that these knobs pull the strings to make each mode its own instrument.</p>

<p>We spoke in chapter one about the difference between modes and scenes, but an additional word is appropriate here on how the foreground knobs behave when moving between modes and scenes.</p>

<p><em>When you load a different <strong>mode</strong>, the current values of the foreground knobs are maintained for the new mode that is loaded.</em> In other words, if you just turned foreground knob <code>1</code> to 3 o’clock and foreground knob <code>3</code> is set to 10 o’clock, ETC will supply those exact same settings to any successive modes that you load.</p>

<p>If the foreground knobs are assigned consistently across different modes you are using, this can offer more stable transitions between modes. For example, if you have loaded several modes that use foreground knob <code>4</code> as a uniform color selection parameter, then that setting would be interpreted similarly as you switch from mode to mode, using that same color value across successive modes. And even if your modes assign their foreground knobs in completely different ways, ETC’s behavior will at least preserve your settings when you switch over to another mode and then back to your original selection.</p>

<p><em>When you load a different <strong>scene</strong>, the current values of the foreground knobs are ignored in favor of the settings stored in the scene.</em> In other words, loading a scene will load the scene’s stored foreground control values into ETC, leaving no connection (for the moment) between the values currently used by the software engine and the physical position of the foreground control knobs.</p>

<p>As we discussed in the concepts portion of chapter one, each scene is basically a snapshot of ETC’s current mode state. This includes the mode that is being used as well as the value of each of the foreground controls at the time the scene was captured (and the values of the <em>Background Color</em> knob and the <em>Auto Clear Toggle</em> button). While turning the foreground knobs and switching between modes offers an “organic” experience, loading a scene is a relatively abrupt act, jumping directly to settings that were stored at another time, in another place. This is by design.</p>

<p>Turning a foreground knob is always an absolute gesture: as soon as a change in the knob’s value is detected, it will be applied to ETC’s video engine. This holds true after a scene has been loaded. By turning a foreground knob, the new value there will take over, replacing the scene’s stored value and restoring the connection between the physical control and the software. Again, this may be an abrupt gesture at first —&nbsp;particularly if the stored value and the current knob position are on opposite sides of the control range. But once the knob is turned, all successive tweaks will create smooth value transitions.</p>

<p>And as for how to switch between different modes and scenes (and store new scenes), well it’s funny that you ask…</p>

<hr />

<h2>Row 4: Functional Controls</h2>

<p>The top bottom of ETC has a number of navigation and action-based options, all in the form of tasteful maple buttons. We will look at each niblet, going from left to right.</p>

<p><strong>The <em>Mode Selector</em> buttons</strong> are first up. This pair of trigger buttons on the far left around the eyeball icon allow you to step backward (left) or forward (right) through the modes that are currently loaded on your USB drive.</p>

<p><strong>The <em>Scene Selector</em> buttons</strong> are next. This pair of trigger buttons around the clapperboard icon allow you to step backward (left) or forward (right) through all stored scenes.</p>

<p><strong>The <em>Scene Save</em> button</strong> follows the <em>Scene Selector</em> buttons. This trigger button with the floppy disk icon (remember those?) takes various performance values&nbsp;— your current mode selection, the values of all four foreground controls, the background color setting, and the state of the <em>Auto Clear Toggle</em> button — and stores them to a new scene. This new scene is placed at the end of the scene list.</p>

<p>Additionally, if you loaded a scene, adjusted the settings, and now want to update the original scene instead of a saving a new one, you can do that. By pressing the <em>Scene Save</em> button and holding it for about two seconds, the most recently loaded scene will be overwritten with the current settings.</p>

<p><strong>The <em>Screenshot</em> button</strong> is a trigger with a camera icon. When pressed, the output of the current video mode is captured to a still image file on ETC’s USB drive. Screenshots created will not include the <em>On Screen Display</em>, even if this overlay is currently visible via the <code>HDMI Out</code> port.</p>

<p>Output files are number from zero (<code>0</code>), are saved as JPEG files (for example, <code>0.jpg</code>, <code>1.jpg</code>, and so forth), and share the specs of ETC’s video output: 1280 pixels wide, 720 pixels high, and a resolution of 72 pixels per inch (PPI).</p>

<p>To access these files, first safely shutdown ETC. You can then connect its USB drive to your own computer. All screenshots will be located in the <code>Grabs</code> folder in the drive’s root (or top) directory.</p>

<p><strong>The <em>Trigger</em> button</strong> is on the bottom right of the panel, and its icon is a rectangle containing an X, marked for action! Pressing this button triggers an assigned visual function within most modes. This trigger action is the equivalent of having audio from the <code>Audio In</code> port cross the threshold. It is most commonly used in <em>trigger modes</em> (as discussed in chapter one), but any mode can connect a function to the threshold behavior.</p>

<p>Pressing the <em>Trigger</em> button will also fill ETC’s buffer of recently received samples with a sine wave. Together with the threshold trigger behavior described above, these two functions make the <em>Trigger</em> button a useful substitute when you do not have audio flowing into ETC. With that being said, many modes can also make use of these trigger messages to supplement incoming audio signals so do try it with all kinds of modes.</p>

<hr />

<h2>The Ports</h2>

<p>Most of the ports are on the back of ETC, and many of them have already come up in our conversation, but we’ll take a moment to touch on each of them with any information relevant to this conversation of general functionality.</p>

<p><strong>The <code>9VDC</code> power port</strong> is made for the power supply including with ETC. As with all Critter &amp; Guitari instruments, the power supply’s output specifications are as follows: 9VDC, 1000mA, and a tip with center-positive polarity. If you are uncertain whether a power supply will work with ETC, don’t plug it in to find out.</p>

<p><strong>The <code>HDMI Out</code> port</strong> serves as the video output for ETC.</p>

<p>Next is an unlabeled microSD card slot. This slot comes preloaded with a card that serves as the internal microcomputer’s root disk. We do not recommend ejecting or otherwise manipulating this card as nothing good will come of it.</p>

<p><strong>The <code>MIDI  In</code> port</strong> is for connecting an external MIDI controller. Information on ETC’s MIDI implementation is found in chapter three.</p>

<p><strong>The <code>Audio In</code> port</strong> is a <code>-Mono-</code>(phonic) 1/4&quot; input for audio signal. This audio is made available to your modes in two ways. First, a list of the most recent 100 samples is always available for drawing purposes. And second, the incoming audio is continually assessed to determine if it exceeds a threshold level (roughly 80% of maximum possible amplitude), highly useful for commencing a function.</p>

<p><strong>The <code>Foot Switch</code> port</strong> is a 1/4&quot; jack. It is intended to be connected to a keyboard sustain-/damper-style pedal.</p>

<p>If scenes are stored on your USB drive, an “on” message received at the <code>Foot Switch</code> port advances to the next stored scene. If no scenes are present on the USB drive, each message loads the next available mode instead. In both cases, this action “wraps around,” going from the last available scene/mode back to the first one, and so on.</p>

<p>ETC assumes that any connected foot switch has a “normally open position” (positive polarity).</p>

<p>Finally, <strong>the two USB ports</strong> reside on the right side panel. We already mentioned the tiny USB drive that comes with ETC and must be connected for the device to properly boot up. For more information on working with the USB drive and its formatting, see chapter three.</p>

<p>If you need more USB ports, you could connect a hub to one of these ports. That hub and any other devices you connect should be class compliant, meaning that is doesn’t require a special software driver to be installed. This will help to ensure compatibility with ETC.</p>

<hr />

<h2>An Epilogue on Basic Controls</h2>

<p>Note that we aren’t discussing how to produce certain types of images or effects. While the controls offered by ETC are always the same, each mode is unique its own right and can be used in ways that even we can’t imagine. Do consult the factory modes reference (URL) for a sense of the included options and their range. And if those provided options aren’t enough, then continue with us to the next chapter.</p>

<h1>Chapter Three: Accessing ETC™ from Elsewhere</h1>

<h3>Getting into and out of ETC.</h3>

<p>First, we are glad you made it this far! And just in case you skipped straight to this chapter, be sure to go back and read chapter two! We are assuming that general operation of ETC is fairly clear at this point. So with that out of the way, let’s proceed.</p>

<p>In this chapter, we are going outside of ETC itself to focus on how it interacts with the wider world. While ETC can be run successfully with its factory modes and its own on-board controls, you can definitely expand this performance device with new modes and/or additional sources of control. Here we will see ways to grow ETC’s range in each of these dimensions.</p>

<p>We will start with some basics, looking at the folder structure used by ETC’s USB drive, where your modes and screenshots all live. If you want to load additional modes or simply download your screenshots, you will need to work with the USB drive (and your own computer) to place the new modes and their support files in the right place. Second, we will look at accessing the USB drive by connecting it to your computer. And finally, we’ll look at ETC’s MIDI implementation. This will be useful if you want to connect external MIDI — including USB MIDI —&nbsp;controllers to ETC, or even if you pair ETC with an external sequencer.</p>

<p>If you are searching for additional modes of expression, you have come to the right place. Let’s make ETC that bigger boat…</p>

<hr />

<h2>The USB Drive’s Folder Structure</h2>

<p>As has been mentioned, ETC will only properly work while a USB drive is attached to it. Modes are run directly from this attached USB drive. (While not mission-critical, scenes and screenshots are also stored to this drive.) This could be the flash drive included with ETC or another USB disk that is appropriately set up. Some rules apply:</p>

<ul>
	<li>This USB disk should be formatted with a FAT file system, often associated with MS-DOS.</li>
	<li>This USB drive must contain a folder called <code>Modes</code> at its top-level. (This name is case-sensitive.) All modes to be loaded must live here, as detailed below.</li>
	<li>The top-level of the USB drive may also contain a folder called <code>Grabs</code> for housing screenshots that are taken, a file called <code>Scenes.csv</code> for recording all scenes that are stored, and a <code>MIDI-Channel.txt</code> file that sets the incoming MIDI channel that ETC listens to. If absent, these items may be automatically created when needed.</li>
</ul>

<p>The following is an example directory listing of an ETC-ready USB drive. You can see four modes here, each with a required <code>main.py</code> file, as well as the <code>Grabs</code> folder and a <code>Scenes.csv</code> file. </p>

<pre><code>Grabs\
	0.jpg
	1.jpg
	2.jpg
MIDI-Channel.txt
Modes\
	S - Circle Scope Connected\
		main.py
	S - Feynman\
		main.py
		main.pyc
	T - Density Cloud\
		main.py
		main.pyc
	T - Spanish Flash Cards\
		font.ttf
		main.py
		main.pyc
		spanish.py
		spanish.pyc
Scenes.csv
</code></pre>

<p>A couple items worth noting here about the modes:</p>

<ul>
	<li>In the four mode folders shown above, all of them have the required <code>main.py</code> file. As long as these Python script files contain the minimum requirements for an ETC mode, they will all be treated as valid modes and loaded when the device starts up. (For information on programming or editing modes, see chapter four.)</li>
	<li>Three of these mode folders also include <code>main.pyc</code> files. These intermediary files are automatically created by the Python compiler in ETC. These files can speed up future interpretations of their script, but the PYC files are not required or needed. (The first mode listed here has no <code>main.pyc</code> file, suggesting that it is a new mode which has not yet been run by ETC.)</li>
	<li>Other files necessary for your mode should also be included in the mode folder. This could include images, additional Python scripts, font files, or anything else that might make sense.</li>
	<li>Also note that mode folders can also contain subfolders, which can be recognized by contained mode.</li>
</ul>

<hr />

<h2>Taking the USB Drive to your Computer</h2>

<p>Whether you want to load new modes, download some of your screenshots, or edit the <code>Scenes.csv</code> file or the modes themselves, any of these actions requires accessing the files on ETC’s USB drive. One way to do that is connecting the USB drive to a computer. We will discuss that here. (A second way to edit modes is with the USB <strong>Wi-Pi</strong> interface [a separate purchase] for wireless access. We will cover that in the chapter four.)</p>

<p>If the USB drive is currently connected to ETC, you must first shut down the unit by holding the <em>Shutdown</em> button for a couple seconds. You will then see the <em>Status LED</em> turn pink while the system is shutting down, and then the LED will go dim. Only when the <em>Status LED</em> has gone out is it safe to disconnect the USB drive.</p>

<p>When using the included USB drive, be sure it is flipped the right way before connecting to your computer. The drive that comes with ETC has an extremely low profile, consisting of the bottom half of most standard USB connectors/cables. As such, it is possible to plug the drive in upside down. This is generally harmless but is better avoided.<br/>Be sure that the exposed pins — I think of them as teeth —&nbsp;are facing “up,” toward wherever the top of a connected USB cable would go. (On Mac laptops, for example, the pins should face upward, toward the sky.)</p>

<p>Once the drive is connected and seen by your computer, it would appear somewhat like the following.</p>

<figure><img src="ETC_example_filestructure.png"/></figure>

<p>The top level of my USB drive, whose disk name is <code>ETC</code>, is shown above. This root-level does indeed contain the <code>Grabs</code> folder, where three screenshots have been stored. Now would be a good time to move those images to your computer for your own use.</p>

<p>A suggestion about screenshots. While you could copy files to your computer and leave them in place on the USB drive, a better practice is to regularly remove your screenshots from the USB drive. It is easy to run out of space on the USB drive by amassing screenshots, either slowly or quickly. Instead of running low on space without realizing it, just remove these images regularly.</p>

<p>Also at the top level is the <code>Scenes.csv</code> file. This file of comma-separated values is readable if you open it in a text editor, with each line looking something like this:</p>

<pre><code>bouncing-ball,0.0,0.2668621700879765,0.5141739980449658,0.7526881720430108,1.0,False
</code></pre>

<p>These values represent:</p>

<pre><code>Mode, Foreground 1 Control knob, Foreground 2 Control knob, Foreground 3 Control knob, Foreground 4 Control knob, Background Color knob, Auto Clear Toggle button
</code></pre>

<p>If you are brave and interested, you could try editing these scenes values or simply reordering the lines. But you might want to make a local copy of the file first, just in case. (If things get out of hand, you can always just deleted the <code>Scenes.csv</code>. When a new file is needed, ETC will create it.)</p>

<p>Inside of the top-level <code>Modes</code> folder, the four modes are selected (with blue coloration), and their contents are exposed. So in the example shown above, the four modes available on ETC would be <code>S - Circle Scope Connected</code>, <code>S - Feynman</code>, <code>T - Density Cloud</code>, and <code>T - Spanish Flash Cards</code>. And once more, the practice with factory modes is that a leading <code>S - </code> indicates a scope mode while a leading <code>T - </code> signifies a trigger mode (see chapter one).</p>

<p>When working with these modes, you will most likely want to work with their folders rather than handling the files within each folder. For example:</p>

<ul>
	<li><em>If you want to add a new mode to ETC,</em> make sure to copy the full folder into the USB drive’s <code>Modes</code> folder. (And if you downloaded a ZIP file, make sure that you have decompressed it to a folder before moving it to ETC’s USB drive.)</li>
	<li><em>If you want to back a mode up,</em> copy the folder over to your computer.</li>
	<li><em>If you want to rename a mode,</em> rename the folder.</li>
	<li><em>If you want to duplicate a mode and make changes to the new copy,</em> duplicate the folder and name the copy something different.</li>
	<li><em>If you want to delete a mode,</em> make sure to delete the entire mode folder.</li>
</ul>

<p>In short, if you aren’t editing the files themselves, then working with the files within the mode’s folder can only cause problems.</p>

<p>Finally, note that any other folders or files located on the USB drive will likely be ignored by ETC. This means you could keep a backup folder of working modes on the USB drive while editing the “live” versions. Or this could be handy for having different “set lists” of modes or even different scene files. The set list idea would be to duplicate either your <code>Modes</code> folder or <code>Scenes.csv</code> file, and then rename the version that you would like to save for future use. Just make sure that the proper files and folders have the proper names before you hit the stage!</p>

<hr />

<h2>ETC’s MIDI Configuration</h2>

<p>As ETC’s <code>MIDI In</code> port suggests, external MIDI controllers can be connected to it. In addition to devices connect by regular(/old-fashioned) five-pin DIN connectors, USB MIDI devices can also be used with ETC. To ensure compatibility, we suggest that you select a class compliant USB MIDI controller. Any controller that requires the installation of a driver may, at best, not work as expected.</p>

<p>To properly interact with ETC, we need to know the MIDI implementation of this device. To begin with, ETC only listens to incoming MIDI messages that are on the specified channel (by default, MIDI channel 1). And only a small subset of MIDI messages has an actual effect on ETC’s operating modes.</p>

<p>In other words, your controller may send some messages that ETC doesn’t recognize, and that’s okay. These messages won’t produce any effect on ETC, but they won’t create any problems either so don’t worry with “disabling active sensing,” etc. etc.</p>

<p> Let’s start by examining the different type of messages that ETC uses. We will also end with a word on changing the incoming MIDI channel that ETC responds to.</p>

<h4>Control Change Messages</h4>

<p>Incoming control change messages using controller numbers <code>21</code> through <code>25</code> have an effect on ETC. The following knobs correspond to the listed controller number:</p>

<ul>
	<li>Controller Number <code>21</code> &gt; <em>Foreground 1 Control</em> knob</li>
	<li>Controller Number <code>22</code> &gt; <em>Foreground 2 Control</em> knob</li>
	<li>Controller Number <code>23</code> &gt; <em>Foreground 3 Control</em> knob</li>
	<li>Controller Number <code>24</code> &gt; <em>Foreground 4 Control</em> knob</li>
	<li>Controller Number <code>25</code> &gt; <em>Background Color</em> knob</li>
</ul>

<p>Each incoming message’s value replaces the current value of the respective controller. So even if foreground knob 2 is turned all the way to the right, an incoming controller message of number <code>22</code> with a value <code>0</code> will change foreground controller 2’s value to zero. Once you move the <em>Foreground 2 Control</em> knob again, its control will be restored.</p>

<h4>Program Change Messages</h4>

<p>Program change messages received by ETC switch to the scene specified by the message’s value. So if a program change message with a value of <code>1</code> is received, ETC will switch to its first stored scene, and a program change message with value <code>4</code> would switch to the fourth scene, etc.</p>

<p>If no scenes are stored on ETC, then these program change messages will similarly map to the loaded modes. So a program change message with value <code>1</code> would switch to the first mode, <code>9</code> to the ninth mode, etc.</p>

<h4>Note Messages</h4>

<p>All incoming note messages (again, on the global MIDI track) are received by ETC. It provides information on these note messages in two ways:</p>

<ul>
	<li>ETC tracks all incoming note messages, keeping tabs on which pitches are on or off at any given time.</li>
	<li>A lot like a flag on a mailbox, ETC provides a notification whenever a MIDI note on message(s) has been received since the previous video frame. This can be very handy for creating a “note trigger” effect in your modes.</li>
</ul>

<p>Any mode can use either or both of these status data.</p>

<h4>MIDI Clock Messages</h4>

<p>ETC also understands a couple of MIDI system real-time messages. Many sequencers support this clocking method, but it is simple enough that you could build it into other environments as well (such as Pure Data [read: for <strong>Organelle</strong>], Max, Reaktor, etc.).</p>

<p>MIDI’s concept for system real-time messages is that a <em>timing clock</em> message is received 24 times per quarter note for the purposes of synchronization. Accordingly, each time ETC receives a timing clock message, an internal counter is increased by one step. After the 24th step, the counter returns to its low position and counts upward again. Additionally, any real-time <em>start</em> message that is received triggers also causes the counter to be reset on the next clock beat.</p>

<p>This internal counter value of ETC is accessible to any mode that wishes to use it. By using select steps of the counter, you can create effects that are rhythmically synchronized to your liking.</p>

<p>And please note that MIDI clock messages are <em>system</em> MIDI messages. That means that these messages will be received and used regardless of ETC’s current global MIDI channel.</p>

<h4>Changing the Global MIDI Channel</h4>

<p>Earlier we noted a file called <code>MIDI-Channel.txt</code>at the top level of the USB drive. This plain text file should contain only a single number. If the number is between <code>1</code> and <code>16</code>, then ETC will listen only to that specified MIDI channel for incoming MIDI messages, and all other channels will be ignored.</p>

<p>Setting the contents of the text file to <code>0</code> (the number zero) will switch ETC to a kind of omni mode, telling the device to ignore the MIDI channel of incoming message and to respond to everything it receives. As an example, this might be preferable if you are using a MIDI controller that has both keys and/or knobs (typically transmitted on channel 1) and drum pads (often sent on channel 10).</p>

<p>Finally, if this <code>MIDI-Channel.txt</code> file is deleted or not readable, ETC will default to MIDI channel 1 when it boots up.</p>

<h1>Chapter Four: Programming For ETC™, and Access via Wi-Fi</h1>

<h3>For those with a text editor and a dream.</h3>

<p>Well, here we are. The place where dreams and/or ETC modes are made.</p>

<p>First of all, this chapter may not be for you. If we may say so ourselves, ETC is rather functional and expressive without getting into coding. So if you are comfortable with using ETC and would rather stick with the artistic side of your brain, that is great. Focus on what is going to benefit you the most, and go in peace. If you ever want to come back, we will be here. Waiting.</p>

<p>And while this chapter focuses on how ETC works and the methods available to you within this framework, we are not going to teach you how to code. We don’t have enough pages or Red Bull to do that here. But don’t despair. Now more than ever, there is a bounty of resources available that will help you learn about programming in general and about particular languages (such as <strong>Python</strong>). Searching the internet, the library, or even local computer classes on offer will give you some good leads and help you find a way forward to start programming.</p>

<p>Now, if you enjoy coding already (or are considering it), or if you have some video ideas that you need to express, then let’s proceed. Just pull that lever to pop the hood.</p>

<p>In this chapter, we will start with the concepts and requirements for any ETC mode. Each mode doesn’t require much, but talking about what does need to be there will give us a good picture of how ETC operates. We will then outline ETC’s application program interface (API). Beyond the required pieces, these are the available functions and properties that you can make use of in any mode. Finally, we will look at connecting to ETC for the purpose of editing modes directly while the device is running. This can be done via the optional USB Wi-Fi interface, which is an <a href="https://www.critterandguitari.com/collections/accessories">additional purchase</a>.</p>

<p>So this is the road before us. We have already seen how ETC handles; now let’s change the oil and what make him purr…</p>

<hr />

<h2>How Mode Scripts Work</h2>

<p>A word or two on how ETC actually does its work will go a long way. We will spend a moment on the languages at play and the system behavior of ETC, and then we will talk about the basic requirements of a mode.</p>

<h4>Python, Pygame, and ETC</h4>

<p>As we said early on, ETC’s modes are written in <strong>Python</strong> using the graphics library of <strong>Pygame</strong>. So <strong>Python</strong> is the programming language in use, and the graphics library executing the drawing comes from <strong>Pygame</strong>.</p>

<p><strong>Python</strong> has a rich standard library with numerous modules, any of which can be used in your modes. A full list of modules can be found in <a href="https://docs.python.org/2/library/">Python’s documentation</a>. Going through the factory modes, you will see such modules as <code>glob</code>, <code>imp</code>, <code>math</code>, <code>random</code>, and <code>time</code> in use. To learn more about how any of the library modules work or more about <strong>Python</strong> itself, the documentation link above is a wonderful place to start.</p>

<p><strong>Pygame</strong> is a set of <strong>Python</strong> modules that were originally written for video game development. ETC is using the graphics library of <strong>Pygame</strong> to create our visuals. A full list of available modules can be found in <a href="http://www.Pygame.org/docs/">Pygame’s documentation</a> under the <em>Reference</em> section. Some of the factory modes make use of additional libraries such as <code>pygame.freetype</code> and <code>pygame.gfxdraw</code>, but other graphics-related modules could be used as well.</p>

<p><strong>Pygame</strong> renders its graphical output to a <em>surface</em>. This is how we connect our <strong>Python</strong> scripts to our <strong>Pygame</strong> output, which we will see in the next section.</p>

<p>When ETC starts up, it identifies all valid modes within the USB drive’s <code>Modes</code> folder. And it then loads all of these modes simultaneously. This parallel behavior is what makes switching between modes so instantaneous and smooth, but it also adds a couple things worth considering:</p>

<ul>
	<li><strong>A processor-intensive mode will always be running.</strong> If you load a mode that taxes ETC and its processor, realize that this mode will be running even when another mode is loaded. While we expect performance to be relatively consistent under different situations, be aware of this in case you are troubleshooting performance issue.</li>
	<li><strong>Keep your support files to a minimum.</strong> A good example would be a mode that loads images. We’d advise you to keep the images within a mode folder to 10MB or less. Your mileage will definitely vary, but that is a one size fits all suggestion.<br/>Also note that the size of loaded image files could often be optimized. If you download a photo straight from your camera, you’d do well to reduce the resolution to something closer to or below ETC’s output resolution (1280 by 720). As with all rules, there can be exceptions, but there you go.</li>
</ul>

<h4>Minimum Mode Requirements</h4>

<p>Each mode has only four basic suggestions to successfully be loaded and (hopefully) produce graphical output:</p>

<ol>
	<li><strong>Load the “pygame” module.</strong> As with any module in <strong>Python</strong>, this is done with a leading <code>import</code> statement. So any ETC mode script should begin with…

		<pre><code>import pygame
		</code></pre></li>
	<li><strong>Have a “setup” function (please).</strong> This is actually optional but highly suggested. <code>setup()</code> will get called automatically when the mode is loaded. This is a clean way to run any operations that are only needed once, before video is being rendered.</li>
	<li><strong>Have a “draw” function.</strong> <code>draw()</code> is the function that is run 30 times per second (think 30 frames per second [fps]) to paint each frame of video output. Common activities here including taking in any control changes since the last frame, redrawing with updated audio information, executing changes based on any trigger or other messages received, etc. etc.<br/>Note that code in this block will get hammered so do be a little parsimonious, only including actions that need to be taken for each and every frame.</li>
	<li><strong>Route your output to the “screen” surface.</strong> ETC creates a reserved <strong>Pygame</strong> surface called <code>screen</code>. This surface is what gets sent out for display via the HDMI port.</li>
</ol>

<h4>A Simple Mode Example</h4>

<p>Taking all these points into consideration, here is a very simple ETC mode example…</p>

<pre><code>import pygame

def setup(screen, etc):
	pass

def draw(screen, etc):
	size = 640
	pos = (510, 500)
	color = (255, 0, 0)
	pygame.draw.circle(screen, color, pos, size, 0)
</code></pre>

<p>Walking through this basic <code>main.py</code> example, we start by loading the <code>pygame</code> module, as outlined above in step one. We then define a <code>setup()</code> function. This one is blank, but it is good to have it as a placeholder for use when necessary.</p>

<p>Next comes the <code>draw()</code> function. The first three lines of the function are defining local variables that are used in the <code>pygame.draw.circle()</code> function. And as the first argument in the example indicates, this function is pointing at the <code>screen</code> surface, getting our draw messages out if ETC through the HDMI output port.</p>

<p>That is about the simplest mode we could make, and its result is equally simple — a red circle is drawn near the middle of the screen, each and every frame, forever. This simple example is a good framework for examining the factory modes and for understanding how to structure your own modes. Our only suggestion is that you probably should send different images out ETC from time to time.</p>

<hr />

<h2>ETC’s API</h2>

<hr />

<h2>Wirelessly Programming with the USB Wi-Fi Interface</h2>

<p>In the chapter three, we looked at the format of the USB drive as well as how to add new modes and work with files and folders when the drive is connected directly to an show compute. And earlier in this chapter, we have covered the basics of making and editing modes for ETC.</p>

<p>Combining this information, you could simply disconnect ETC’s USB drive whenever you want to edit or load new patches. This would work just fine, but by requiring </p>

<p> but this would not allow you to quickly see the results of your code and changes you make. So we thought of a new way to approach this.</p>

<p>In order to keep ETC running <em>and</em> allow you to edit its primary scripts (the <code>main.py</code> files of each mode), we have made ETC ready to work with the <em>USB Wi-Fi interface</em> that are available for purchase.</p>

<p>After minimal configuration, you can then connect the <em>USB Wi-Fi interface</em> to one of ETC’s USB ports.</p>











    </div>
  </div>


  <footer>  
    <div class="w3-container w3-theme-l1">
      <p>ETC Manual &copy; 2017 Critter &amp; Guitari</p>
    </div>
  </footer>

<!-- END MAIN -->
</div>

<script>
// Get the Sidenav
var mySidenav = document.getElementById("mySidenav");

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidenav, and add overlay effect
function w3_open() {
    if (mySidenav.style.display === 'block') {
        mySidenav.style.display = 'none';
        overlayBg.style.display = "none";
    } else {
        mySidenav.style.display = 'block';
        overlayBg.style.display = "block";
    }
}

// Close the sidenav with the close button
function w3_close() {
    mySidenav.style.display = "none";
    overlayBg.style.display = "none";
}
</script>

</body>
</html>

